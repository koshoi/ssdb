#!/bin/bash

set -eu
set -o pipefail

DEBUG="${SSDB_DEBUG:-}"

SNAPDIR="${SSDB_SNAPDIR:-/tmp/ssdb_snap}"
DBNAME="${SSDB_DATABASE:-default}"
DEBUG_INFO="$(printf '[%6d:%s]' "$$" "$USER")"
LOCK_SLEEP_PERIOD=0.1
LOCK_MAX_ATTEMPT=100

CR="10"
BUFSIZE=10

KEY_POSITION=0
META_POSITION=1
VALUE_POSITION=2

TAKEN_LOCKS=()

DEPENDENCIES=(base64 cat cat sed printf mkdir sleep echo hexdump)
mkdir -p "$SNAPDIR"

function _log_prefix {
	local level="$1"
	local _caller
	_caller="$(caller 2)"
	_caller=($_caller)
	echo -e "$(date '+%Y-%m-%dT%H:%M:%S')\t[$level:${_caller[0]}:${_caller[1]}]\t"
}

function _log {
	local level="$1"
	local msg="$2"
	echo "$(_log_prefix "$level")${msg}" 1>&2
}

function debug {
	if [ -n "$DEBUG" ]; then
		_log 'debug' "$DEBUG_INFO  $*"
	fi
}

function warn {
	_log 'warning' "$*"
}

function error {
	_log 'error' "$*"

	# Disgusting hack for empty arrays on bash < 4.4
	if [ 0 -ne "${#TAKEN_LOCKS[@]}" ]; then
		for l in "${TAKEN_LOCKS[@]}"; do
			unlock "$l"
		done
	fi

	exit 127
}

for dep in "${DEPENDENCIES[@]}"; do
	if ! type "$dep" 1>/dev/null 2>/dev/null; then
		error "Unmet dependency: $dep"
	fi
done

function max {
	if [ "$1" -gt "$2" ]; then
		echo "$1"
	else
		echo "$2"
	fi
}

function min {
	if [ "$1" -lt "$2" ]; then
		echo "$1"
	else
		echo "$2"
	fi
}

function half {
	local from
	local to
	local len
	from=$(max "$1" "$2")
	to=$(min "$1" "$2")
	len=$(( to - from ))
	echo $(( from + len / 2 ))
}

function fsize {
	local f="$1"
	local size
	size=$(wc -c "$f")
	size=($size)
	echo "${size[0]}"
}

function format_value {
	local value="$1"
	if echo "$value" | grep -q '\s'; then
		printf 'format=b64 %s' "$(printf '%s' "$value" | base64 -w 0)"
		return 0
	fi

	local printable
	printable=$(echo "$value" | strings -n 1)
	if [ "$printable" == "$value" ]; then
		printf 'format=raw %s' "$value"
		return 0
	fi

	printf 'format=b64 %s' "$(printf '%s' "$value" | base64 -w 0)"
	return 0
}

function get_bytes {
	local file="$1"
	local from="$2"
	local to="$3"

	local len
	len=$(( to - from ))

	#debug "$(hexdump -ve '1/1 "(%_ad:%02d:"' -e '1/1 "%_c) "' -s "$from" -n "$len" "$file")"

	# https://brendanzagaeski.appspot.com/0006.html
	#
	#  no default trash
	#        |
	#        v
	hexdump -ve '1/1 "%02d "' -s "$from" -n "$len" "$file"
	#            ^
	#            |
	#    1 byte by 1 byte
}

function get_line {
	local file="$1"
	local from="$2"

	if [ "$from" -eq 0 ]; then
		head -n 1 "$file"
	else
		tail -c "$(( $(fsize "$file") - from - 1 ))" "$file" | head -n 1
	fi
}

function seek4 {
	local file="$1"
	local pos="$2"
	local byte="$3"
	local direction="${4:-1}"

	debug "seek4: file=$file from=$pos byte=$byte direction=$direction"
	local size
	size=$(fsize "$file")
	local nextpos="$pos"

	local found=''
	until [ ! -z "$found" ]; do
		if [ "$direction" -lt 0 ]; then
			pos=$(( pos - BUFSIZE ))
			pos=$(max 0 "$pos")
		else
			nextpos=$(( pos + BUFSIZE ))
			nextpos=$(min "$nextpos" "$size")
		fi

		if [ "$pos" -ge "$size" -o "$pos" -le 0 ]; then
			debug "seek4: file=$file size=$size pos=$pos d=$direction quiting"
			echo -1
			return 0
		fi

		local bytes
		bytes=($(get_bytes "$file" "$pos" "$nextpos"))

		local cnt=0
		local seek=0
		local len="${#bytes[@]}"
		[ "$direction" -lt 0 ] && seek=$(( len - 1 ))

		until [ "$cnt" -eq "$len" ]; do
			cnt=$(( cnt + 1 ))
			local b="${bytes[$seek]}"
			if [ "$b" == "$byte" ]; then
				found=$(( pos + seek ))
				break
			fi
			seek=$(( seek + direction ))
		done

		if [ "$direction" -lt 0 ]; then
			nextpos="$pos"
		else
			pos="$nextpos"
		fi
	done

	echo "$found"
	return 0
}

function split {
	local del="$1"
	local str="$2"
	local IFS="$del"
	read -ra arr <<< "$str"
	for e in "${arr[@]}"; do
		echo "$e"
	done
}

function meta2tag {
	local meta="$1"
	local metatag="$2"

	local metalist
	metalist=($(split ',' "$meta"))
	for tagline in "${metalist[@]}"; do
		local tag="${tagline%=*}"
		local tagvalue="${tagline#*=}"
		if [ "$metatag" == "$tag" ]; then
			printf '%s' "$tagvalue"
			return 0
		fi
	done

	return 1
}

function line2key {
	debug "line2key '$1'"
	local l="$1"
	local larr=($l)
	echo "${larr[$KEY_POSITION]}"
}

function line2meta {
	debug "line2key '$1'"
	local l="$1"
	local metatag="${2:-}"
	local larr=($l)
	local meta="${larr[$META_POSITION]}"
	if [ -z "$metatag" ]; then
		printf '%s' "$meta"
	fi

	meta2tag "$meta" "$metatag"
}

function line2value {
	debug "line2value '$1'"
	local l="$1"
	local larr=($l)
	echo "${larr[$VALUE_POSITION]}"
}

# returns A, B
# A is one of KEYFOUND, APPEND
# B is position where the key should be
function find_position_for_key {
	local file="$1"
	local key="$2"

	local startpos=0
	local endpos
	endpos=$(( $(fsize "$file") - 1 ))

	if [ "$endpos" -eq 0 -o "$endpos" -eq -1 ]; then
		echo "APPEND 0"
		return 0
	fi

	local firstkey
	firstkey=$(line2key "$(head -n 1 "$file")")
	if [[ "$key" < "$firstkey" ]]; then
		echo "APPEND 0"
		return 0
	fi

	if [ "$key" == "$firstkey" ]; then
		echo "KEYFOUND 0"
		return 0
	fi

	local lastkey
	lastkey=$(line2key "$(tail -n 1 "$file")")
	if [[ "$key" > "$lastkey" ]]; then
		echo "APPEND $endpos"
		return 0
	fi

	if [ "$key" == "$lastkey" ]; then
		echo "KEYFOUND $(seek4 "$file" "$endpos" "$CR" -1)"
		return 0
	fi

	local loopcnt=0
	local maxloop=1000

	while [ "$startpos" -ne "$endpos" ]; do
		loopcnt=$(( loopcnt + 1 ))
		local pfx="lc=$loopcnt sp=$startpos ep=$endpos"
		debug "$pfx"
		if [ "$loopcnt" -gt "$maxloop" ]; then
			error "to many loops"
		fi

		pos=$(half "$startpos" "$endpos")
		#debug "$pfx pos=$pos"
		debug "$pfx"

		local foundr
		local foundl
		foundr=$(seek4 "$file" "$pos" "$CR"  1)
		foundl=$(seek4 "$file" "$pos" "$CR" -1)

		debug "fl=$foundl fr=$foundr"

		local linel
		local liner
		linel=$(get_line "$file" "$foundl")
		liner=$(get_line "$file" "$foundr")
		debug "$pfx ll=$linel"
		debug "$pfx lr=$liner"

		local rkey
		local lkey
		rkey=$(line2key "$liner")
		lkey=$(line2key "$linel")

		if [ "$lkey" == "$key" ]; then
			debug "LEFTFOUND AT POSITION=$foundl, line=$linel"
			echo "KEYFOUND $foundl"
			return 0
		fi

		if [ "$rkey" == "$key" ]; then
			debug "RIGHTFTFOUND AT POSITION=$foundr, line=$liner"
			echo "KEYFOUND $foundr"
			return 0
		fi

		if [[ "$key" > "$rkey" ]]; then
			debug "[lr] $pfx [$lkey $key $rkey] setting sp=$foundr"
			startpos="$foundr"
		else
			if [[ "$key" < "$lkey" ]]; then
				debug "[ll] $pfx [$lkey $key $rkey] setting ep=$foundl"
				endpos="$foundl"
			else
				debug "BETWEEN [$lkey $key $rkey]"
				echo "APPEND $foundr"
				exit 0
			fi
		fi
	done

	# this should not happen
	debug "sp=$startpos ep=$endpos"
	exit 1
}


function print_help {
cat <<'EOF'

Welcome to

   __________ ____  ____ 
  / ___/ ___// __ \/ __ )
  \__ \\__ \/ / / / __  |
 ___/ /__/ / /_/ / /_/ /
/____/____/_____/_____/


SSDB stands for Shebang Started DataBase
The main concept of this 'DataBase' is
	1) Being serverless
	2) Being written in bash
	3) Beign written in as clean bash as possible
	4) Being written in single bash file
	5) Having a snapshot that can be easily fixed in vim if needed
	6) Having some sort of isolation, but not necessary

This is key-value DB that stores data in a file
It does not have a server, but it has a client (you are reading help for it at the moment)

Client's are kinda following gentelmens agreement on
'How we, gentelmen, should write to this file called snapshot so it keeps being adequate'

The syntax is simple

ssdb add   KEY VALUE
ssdb del   KEY
ssdb get   KEY
ssdb check KEY
ssdb list
ssdb help

As for now KEY can't contain any whitespaces, special characters and binary shit
Because this is DB for gentlemen, and gentlemen are not going to use that symbols, not to spoil the fun for other gentlemen
I guess I will check for whitespaces easily, not so easy for binary shit

However VALUE can contain any of that

Roadmaps are
	1) Subscribe on any changes to the key
	2) Subscribe on any changes to the key that matches the wildcard 
	3) Replication)))
	4) More data structures (like sets, lists and maybe something else)
	5) More than single database
EOF
}

function lock_name {
	echo "${SNAPDIR}/lock.${DBNAME}.${1:-GLOBAL}"
}

function snap_name {
	local snap="${SNAPDIR}/snap.${DBNAME}"
	touch "$snap"
	echo "$snap"
}

function lock {
	local lock_type="${1:-GLOBAL}"
	local lockdir
	lockdir=$(lock_name "$lock_type")
	TAKEN_LOCKS+=( "$lock_type" )

	debug "Locktype=$lock_type Lockdir=$lockdir"

	local lock_attempt=1

	until mkdir "$lockdir" 2>/dev/null; do
		debug "Attempt to take lock #$lock_attempt"
		lock_attempt=$(( lock_attempt + 1 ))
		sleep $LOCK_SLEEP_PERIOD
		if [ "$lock_attempt" -gt "$LOCK_MAX_ATTEMPT" ]; then
			debug "Failed to take $lock_type lock in $LOCK_MAX_ATTEMPT attempts"
			error "Failed to take $lock_type lock"
		fi
	done

	debug "Lock taken, attempt=$lock_attempt"
}

function unlock {
	local lock_type="${1+GLOBAL}"
	local lockdir
	lockdir=$(lock_name "$lock_type")
	rmdir "$lockdir"
	debug "$lock_type lock removed"
}

function _set_key {
	local key="$1"
	local value="$2"
	local noreplace="${3:-}"

	value=$(format_value "$value")
	local snap
	snap=$(snap_name)

	local findres
	local snapinprogress="$snap.ip"

	if findres=$(find_position_for_key "$snap" "$key"); then
		findres=($findres)
		local postype="${findres[0]}"
		local pos="${findres[1]}"
		if [ "$postype" == "APPEND" ]; then
			debug "appending key=$key at position=$pos"
			if [ "$pos" -eq 0 ]; then
				echo "$key $value" > "$snapinprogress"
				cat "$snap" >> "$snapinprogress"
			else
				head -c "$(( pos + 1 ))" "$snap" > "$snapinprogress"
				echo "$key $value" >> "$snapinprogress"
				tail -c "+$(( pos + 2 ))" "$snap" >> "$snapinprogress"
			fi
		else
			debug "found key=$key at position=$pos"
			local nextcr
			nextcr=$(seek4 "$snap" "$(( pos + 1 ))" "$CR")
			debug "nextcr=$nextcr"
			if [ ! -z "$noreplace" ]; then
				debug "noreplace is set, can't update key value"
				printf "KEY_ALREADY_SET"
				return 1
			fi
			if [ "$pos" -ne 0 ]; then
				head -c "$(( pos + 1 ))" "$snap" > "$snapinprogress"
			fi
			echo "$key $value" >> "$snapinprogress"
			tail -c "+$(( nextcr + 2 ))" "$snap" >> "$snapinprogress"
		fi
		debug "SET FR0=${findres[0]} FR1=${findres[1]}"
	else
		error "failed to find position for key=$key"
	fi

	mv -f "$snapinprogress" "$snap"
}

function run_set {
	lock GLOBAL
	debug "run_set $1 '$2'"

	local result
	if result="$(_set_key "$1" "$2")"; then
		debug "added"
	else
		local EXIT=$?
		debug "failed to set key, $result"
		unlock GLOBAL
		printf "%s" "$result"
		return $EXIT
	fi

	unlock GLOBAL
	printf 'OK'
	return 0
}

function run_add {
	lock GLOBAL
	debug "run_set $1 '$2'"

	local result
	if result="$(_set_key "$1" "$2" noreplace)"; then
		debug "added"
	else
		local EXIT=$?
		debug "failed to set key, $result"
		unlock GLOBAL
		printf "%s" "$result"
		return $EXIT
	fi

	unlock GLOBAL
	printf 'OK'
	return 0
}

function _delete_key {
	local key="$1"
	local snap
	snap=$(snap_name)

	local findres
	local snapinprogress="$snap.ip"

	if findres=$(find_position_for_key "$snap" "$key"); then
		findres=($findres)
		local postype="${findres[0]}"
		local pos="${findres[1]}"
		if [ "$postype" == "APPEND" ]; then
			return 1
		else
			debug "found key=$key at position=$pos"
			local line
			line=$(get_line "$snap" "$pos")
			local nextcr
			nextcr=$(seek4 "$snap" "$(( pos + 1 ))" "$CR")
			debug "nextcr=$nextcr"
			head -c "$(( pos + 1 ))" "$snap" > "$snapinprogress"
			tail -c "+$(( nextcr + 2 ))" "$snap" >> "$snapinprogress"
		fi
		debug "SET FR0=${findres[0]} FR1=${findres[1]}"
	else
		error "failed to find position for key=$key"
	fi

	mv -f "$snapinprogress" "$snap"
}

function run_del {
	lock GLOBAL

	debug "run_del $1"
	if _delete_key "$1"; then
		debug "Found"
	else
		local EXIT=$?
		debug "Not found"
		unlock GLOBAL
		return $EXIT
	fi

	unlock GLOBAL

	printf 'OK'
	return 0
}

# returns full line containing key
function _get_line_with_key {
	local key="$1"
	local no_value="${2-}"

	local snap
	snap=$(snap_name)
	local findres
	local line
	if findres=$(find_position_for_key "$snap" "$key"); then
		debug "findres=$findres"
		findres=($findres)
		if [ "${findres[0]}" == "KEYFOUND" ]; then
			line=$(get_line "$snap" "${findres[1]}")
			debug "line=$line"
			if [ -z "$no_value" ]; then
				printf '%s' "$line"
			fi
			return 0
		fi
	fi
	return 1
}

function run_get {
	lock GLOBAL

	debug "run_get $1"
	local line
	if line="$(_get_line_with_key "$1")"; then
		debug "Found line='$line'"
	else
		local EXIT=$?
		debug "Not Found"
		unlock GLOBAL
		return $EXIT
	fi

	unlock GLOBAL

	local fmt
	fmt=$(line2meta "$line" 'format')
	if [ "$fmt" == 'raw' ]; then
		printf '%s' "$(line2value "$line")"
		return 0
	fi

	if [ "$fmt" == 'b64' ]; then
		printf '%s' "$(line2value "$line")" | base64 -d
		return 0
	fi

	error "Unknown fmt=$fmt"
}

function run_check {
	lock GLOBAL

	debug "run_check $1"
	if _get_line_with_key "$1" 1; then
		unlock GLOBAL
		debug "Key present"
		return 0
	else
		local EXIT=$?
		unlock GLOBAL
		debug "Key absent"
		return $EXIT
	fi
}

function _list_keys {
	local snap
	snap=$(snap_name)

	sed 's/ .*//' "$snap"
}

function run_list {
	lock GLOBAL

	debug "run_list"
	if result="$(_list_keys)"; then
		unlock GLOBAL
		debug "got keys"
		printf '%s\n' "$result"
		return 0
	else
		local EXIT=$?
		unlock GLOBAL
		debug "failed to list keys"
		return $EXIT
	fi
}

COMMAND=""
KEY=""
VALUE=""

GIVEN_COMMAND="${1:-}"

case "$GIVEN_COMMAND" in
	a|add|d|del|delete|g|get|c|check|s|set)
		KEY="${2:-}"
		if [ -z "$KEY" ]; then
			error "KEY can't be empty"
		fi
		case "$GIVEN_COMMAND" in
			a|add|s|set)
				case "$GIVEN_COMMAND" in
					a|add)
						COMMAND="add";;
					s|set)
						COMMAND="set";;
				esac

				if [ -z "${3+x}" ]; then
					error "VALUE is undefined"
				else
					VALUE="$3"
				fi
				;;
			d|del|delete)
				COMMAND="del";;
			g|get)
				COMMAND="get";;
			c|check)
				COMMAND="check";;
		esac;;
	l|list)
		COMMAND="list";;
	h|help)
		COMMAND="help";;
	'')
		error "No command given, consider running 'ssdb help'";;
	*)
		error "'$GIVEN_COMMAND' command is unknown, consider running 'ssdb help'";;
esac
shift

debug "COMMAND=$COMMAND KEY=$KEY VALUE=$VALUE"
debug "SNAPDIR=$SNAPDIR"

case "$COMMAND" in
	add)
		run_add "$KEY" "$VALUE";;
	set)
		run_set "$KEY" "$VALUE";;
	del)
		run_del "$KEY";;
	get)
		run_get "$KEY";;
	check)
		run_check "$KEY";;
	list)
		run_list;;
	help)
		print_help;;
	*)
		error "'$COMMAND' command is parsed but not implemented yet";;
esac
