#!/bin/bash

set -eu
set -o pipefail

SSDB_DEBUG="${SSDB_DEBUG:-}"

SSDB_SNAPDIR="${SSDB_SNAPDIR:-$HOME/.ssdb}"
SSDB_DATABASE="${SSDB_DATABASE:-default}"
CHECK_DEPENDENCIES="${SSDB_CHECK_DEPENDENCIES:-0}"
DEBUG_INFO="$(printf '[%6d:%s]' "$$" "$USER")"
LOCK_SLEEP_PERIOD=0.1
LOCK_MAX_ATTEMPT=100

CR="10"
BUFSIZE=1024

KEY_POSITION=0
META_POSITION=1
VALUE_POSITION=2

TAKEN_LOCKS=()

DEPENDENCIES=(base64 cat sed printf mkdir sleep echo hexdump strings)
mkdir -p "$SSDB_SNAPDIR"

function _log_prefix {
	local level="$1"
	local _caller
	_caller="$(caller 2)"
	_caller=($_caller)
	echo -e "$(date '+%Y-%m-%dT%H:%M:%S')\t[$level:${_caller[0]}:${_caller[1]}]\t"
}

function _log {
	local level="$1"
	local msg="$2"
	echo "$(_log_prefix "$level")${msg}" 1>&2
}

function debug {
	if [ -n "$SSDB_DEBUG" ]; then
		_log 'debug' "$DEBUG_INFO  $*"
	fi
}

function warn {
	_log 'warning' "$*"
}

function error {
	_log 'error' "$*"

	# Disgusting hack for empty arrays on bash < 4.4
	if [ 0 -ne "${#TAKEN_LOCKS[@]}" ]; then
		for l in "${TAKEN_LOCKS[@]}"; do
			unlock "$l"
		done
	fi

	exit 127
}

if [ "$CHECK_DEPENDENCIES" -ne 0 ]; then
	for dep in "${DEPENDENCIES[@]}"; do
		if ! type "$dep" 1>/dev/null 2>/dev/null; then
			error "Unmet dependency: $dep"
		fi
	done
fi

function max {
	if [ "$1" -gt "$2" ]; then
		echo "$1"
	else
		echo "$2"
	fi
}

function min {
	if [ "$1" -lt "$2" ]; then
		echo "$1"
	else
		echo "$2"
	fi
}

function half {
	local from
	local to
	local len
	from=$(max "$1" "$2")
	to=$(min "$1" "$2")
	len=$(( to - from ))
	echo $(( from + len / 2 ))
}

function fsize {
	local f="$1"
	local size
	size=$(wc -c "$f")
	size=($size)
	echo "${size[0]}"
}

function format_value {
	local value="$1"
	if echo "$value" | grep -q '\s'; then
		printf 'format=b64 %s' "$(printf '%s' "$value" | base64 -w 0)"
		return 0
	fi

	local printable
	printable=$(echo "$value" | strings -n 1)
	if [ "$printable" == "$value" ]; then
		printf 'format=raw %s' "$value"
		return 0
	fi

	printf 'format=b64 %s' "$(printf '%s' "$value" | base64 -w 0)"
	return 0
}

function get_bytes {
	local file="$1"
	local from="$2"
	local to="$3"

	local len
	len=$(( to - from ))

	#debug "$(hexdump -ve '1/1 "(%_ad:%02d:"' -e '1/1 "%_c) "' -s "$from" -n "$len" "$file")"

	# https://brendanzagaeski.appspot.com/0006.html
	#
	#  no default trash
	#        |
	#        v
	hexdump -ve '1/1 "%02d "' -s "$from" -n "$len" "$file"
	#            ^
	#            |
	#    1 byte by 1 byte
}

function get_line {
	local file="$1"
	local from="$2"

	if [ "$from" -eq 0 ]; then
		head -n 1 "$file"
	else
		tail -c "$(( $(fsize "$file") - from - 1 ))" "$file" | head -n 1
	fi
}

function seek4 {
	local file="$1"
	local pos="$2"
	local byte="$3"
	local direction="${4:-1}"

	debug "seek4: file='$file' from=$pos byte=$byte direction=$direction"
	local size
	size=$(fsize "$file")
	local nextpos="$pos"

	local found=''
	until [ ! -z "$found" ]; do
		if [ "$direction" -lt 0 ]; then
			pos=$(( pos - BUFSIZE ))
			pos=$(max 0 "$pos")
		else
			nextpos=$(( pos + BUFSIZE ))
			nextpos=$(min "$nextpos" "$size")
		fi

		local bytes
		bytes=($(get_bytes "$file" "$pos" "$nextpos"))

		local cnt=0
		local seek=0
		local len="${#bytes[@]}"
		[ "$direction" -lt 0 ] && seek=$(( len - 1 ))

		until [ "$cnt" -eq "$len" ]; do
			cnt=$(( cnt + 1 ))
			local b="${bytes[$seek]}"
			if [ "$b" == "$byte" ]; then
				found=$(( pos + seek ))
				break
			fi
			seek=$(( seek + direction ))
		done

		if [ "$direction" -lt 0 ]; then
			nextpos="$pos"
		else
			pos="$nextpos"
		fi
	done

	echo "$found"
	return 0
}

function split {
	local del="$1"
	local str="$2"
	local IFS="$del"
	read -ra arr <<< "$str"
	for e in "${arr[@]}"; do
		echo "$e"
	done
}

function meta2tag {
	local meta="$1"
	local metatag="$2"

	local metalist
	metalist=($(split ',' "$meta"))
	for tagline in "${metalist[@]}"; do
		local tag="${tagline%=*}"
		local tagvalue="${tagline#*=}"
		if [ "$metatag" == "$tag" ]; then
			printf '%s' "$tagvalue"
			return 0
		fi
	done

	return 1
}

function line2key {
	debug "line2key '$1'"
	local l="$1"
	local larr=($l)
	echo "${larr[$KEY_POSITION]}"
}

function line2meta {
	debug "line2key '$1'"
	local l="$1"
	local metatag="${2:-}"
	local larr=($l)
	local meta="${larr[$META_POSITION]}"
	if [ -z "$metatag" ]; then
		printf '%s' "$meta"
	fi

	meta2tag "$meta" "$metatag"
}

function line2value {
	debug "line2value '$1'"
	local l="$1"
	local larr=($l)
	echo "${larr[$VALUE_POSITION]}"
}

# returns A, B
# A is one of KEYFOUND, APPEND
# B is position where the key should be
function find_position_for_key {
	local file="$1"
	local key="$2"

	local startpos=0
	local endpos
	endpos=$(( $(fsize "$file") - 1 ))

	if [ "$endpos" -eq 0 -o "$endpos" -eq -1 ]; then
		echo "APPEND 0"
		return 0
	fi

	local firstkey
	firstkey=$(line2key "$(head -n 1 "$file")")
	if [[ "$key" < "$firstkey" ]]; then
		echo "APPEND 0"
		return 0
	fi

	if [ "$key" == "$firstkey" ]; then
		echo "KEYFOUND 0"
		return 0
	fi

	local lastkey
	lastkey=$(line2key "$(tail -n 1 "$file")")
	if [[ "$key" > "$lastkey" ]]; then
		echo "APPEND $endpos"
		return 0
	fi

	if [ "$key" == "$lastkey" ]; then
		echo "KEYFOUND $(seek4 "$file" "$endpos" "$CR" -1)"
		return 0
	fi

	local loopcnt=0
	local maxloop=1000

	while [ "$startpos" -ne "$endpos" ]; do
		loopcnt=$(( loopcnt + 1 ))
		local pfx="lc=$loopcnt sp=$startpos ep=$endpos key=$key"
		debug "$pfx"
		if [ "$loopcnt" -gt "$maxloop" ]; then
			error "to many loops"
		fi

		pos=$(half "$startpos" "$endpos")
		debug "$pfx pos=$pos"

		local foundr
		local foundl
		foundr=$(seek4 "$file" "$pos" "$CR"  1)
		foundl=$(seek4 "$file" "$pos" "$CR" -1)

		debug "fl=$foundl fr=$foundr"

		local linel
		local liner
		linel=$(get_line "$file" "$foundl")
		liner=$(get_line "$file" "$foundr")
		debug "$pfx ll=$linel"
		debug "$pfx lr=$liner"

		local rkey
		local lkey
		rkey=$(line2key "$liner")
		lkey=$(line2key "$linel")

		if [ "$lkey" == "$key" ]; then
			debug "LEFTFOUND AT POSITION=$foundl, line=$linel"
			echo "KEYFOUND $foundl"
			return 0
		fi

		if [ "$rkey" == "$key" ]; then
			debug "RIGHTFTFOUND AT POSITION=$foundr, line=$liner"
			echo "KEYFOUND $foundr"
			return 0
		fi

		if [[ "$key" > "$rkey" ]]; then
			debug "[lr] $pfx [$lkey $key $rkey] setting sp=$foundr"
			startpos="$foundr"
		else
			if [[ "$key" < "$lkey" ]]; then
				debug "[ll] $pfx [$lkey $key $rkey] setting ep=$foundl"
				endpos="$foundl"
			else
				debug "BETWEEN [$lkey $key $rkey]"
				echo "APPEND $foundr"
				exit 0
			fi
		fi
	done

	# this should not happen
	debug "sp=$startpos ep=$endpos"
	exit 1
}


# PREAMBLE Welcome to
# PREAMBLE 
# PREAMBLE    __________ ____  ____
# PREAMBLE   / ___/ ___// __ \/ __ )
# PREAMBLE   \__ \\__ \/ / / / __  |
# PREAMBLE  ___/ /__/ / /_/ / /_/ /
# PREAMBLE /____/____/_____/_____/
# PREAMBLE 
# PREAMBLE 
# PREAMBLE SSDB stands for Supremely Stupid DataBase
# PREAMBLE The main concept of this 'DataBase' is
# PREAMBLE 	1) Being serverless
# PREAMBLE 	2) Being written in bash
# PREAMBLE 	3) Beign written in as clean bash as possible (OK, I fucked it up when I added the dirtiest binary search possible)
# PREAMBLE 	4) Being written in single bash file
# PREAMBLE 	5) Having a snapshot that can be easily fixed in vim if needed
# PREAMBLE 	6) Having some sort of isolation, but not necessary
# PREAMBLE 
# PREAMBLE This is key-value DB that stores data in a file
# PREAMBLE It does not have a server, but it has a client (you are reading help for it at the moment)
# PREAMBLE 
# PREAMBLE Client's are kinda following gentelmens agreement on
# PREAMBLE 'How we, gentelmen, should write to this file called snapshot so it keeps being adequate'
# PREAMBLE 
# PREAMBLE The syntax is simple
# AUTODOC 
# AUTODOC ssdb [OPTIONS] COMMAND KEY ?VALUE
# AUTODOC 
# AUTODOC configurable options are
# AUTODOC 
# AUTODOC 	-D|--database|--db 'dbname'
# AUTODOC 		use given database instead of default one ('default')
# AUTODOC 		can also be configured with SSDB_DATABASE env option
# AUTODOC 
# AUTODOC 	-S|--snapdir 'snapdir'
# AUTODOC 		use given snapshot_directory instead of default one ($HOME/.ssdb)
# AUTODOC 		can also be configured with SSDB_SNAPDIR env option
# AUTODOC 
# AUTODOC 	-d|--debug
# AUTODOC 		use debug
# AUTODOC 		can also be configured with SSDB_DEBUG env option
# AUTODOC 
# AUTODOC almost every command has a shorter version for comfortable usage in console
# AUTODOC 
# AUTODOC As for now KEY can't contain any whitespaces, special characters and binary shit
# AUTODOC Because this is DB for gentlemen, and gentlemen are not going to use that symbols, not to spoil the fun for other gentlemen
# AUTODOC I guess I will check for whitespaces easily, not so easy for binary shit
# AUTODOC 
# AUTODOC However VALUE can contain any of that
# AUTODOC 
# AUTODOC 
# AUTODOC ssdb help
# AUTODOC ssdb h
# AUTODOC 	prints this help
# MILESTONES 
# MILESTONES Roadmaps are
# MILESTONES 	1) Subscribe on any changes to the key
# MILESTONES 	2) Subscribe on any changes to the key that matches the wildcard 
# MILESTONES 	3) Replication)))
# MILESTONES 	4) More data structures (like sets, lists and maybe something else)
# MILESTONES 	5) More than single database
function print_help {
	for tag in PREAMBLE AUTODOC MILESTONES; do
		grep "^# $tag" "$0" | sed "s/^# $tag //g"
	done
}

function lock_name {
	echo "${SSDB_SNAPDIR}/lock.${SSDB_DATABASE}.${1:-GLOBAL}"
}

function snap_name {
	local snap="${SSDB_SNAPDIR}/snap.${SSDB_DATABASE}"
	touch "$snap"
	echo "$snap"
}

function lock {
	local lock_type="${1:-GLOBAL}"
	local lockdir
	lockdir=$(lock_name "$lock_type")
	TAKEN_LOCKS+=( "$lock_type" )

	debug "Locktype=$lock_type Lockdir=$lockdir"

	local lock_attempt=1

	until mkdir "$lockdir" 2>/dev/null; do
		debug "Attempt to take lock #$lock_attempt"
		lock_attempt=$(( lock_attempt + 1 ))
		sleep $LOCK_SLEEP_PERIOD
		if [ "$lock_attempt" -gt "$LOCK_MAX_ATTEMPT" ]; then
			debug "Failed to take $lock_type lock in $LOCK_MAX_ATTEMPT attempts"
			error "Failed to take $lock_type lock"
		fi
	done

	debug "Lock taken, attempt=$lock_attempt"
}

function unlock {
	local lock_type="${1+GLOBAL}"
	local lockdir
	lockdir=$(lock_name "$lock_type")
	rmdir "$lockdir"
	# debug "$lock_type lock removed"
}

function _set_key {
	local key="$1"
	local value="$2"
	local noreplace="${3:-}"

	value=$(format_value "$value")
	local snap
	snap=$(snap_name)

	local findres
	local snapinprogress="$snap.ip"

	if findres=$(find_position_for_key "$snap" "$key"); then
		findres=($findres)
		local postype="${findres[0]}"
		local pos="${findres[1]}"
		if [ "$postype" == "APPEND" ]; then
			debug "appending key=$key at position=$pos"
			if [ "$pos" -eq 0 ]; then
				echo "$key $value" > "$snapinprogress"
				cat "$snap" >> "$snapinprogress"
			else
				head -c "$(( pos + 1 ))" "$snap" > "$snapinprogress"
				echo "$key $value" >> "$snapinprogress"
				tail -c "+$(( pos + 2 ))" "$snap" >> "$snapinprogress"
			fi
		else
			debug "found key=$key at position=$pos"
			local nextcr
			nextcr=$(seek4 "$snap" "$(( pos + 1 ))" "$CR")
			debug "nextcr=$nextcr"
			if [ ! -z "$noreplace" ]; then
				debug "noreplace is set, can't update key value"
				printf "KEY_ALREADY_SET"
				return 1
			fi
			if [ "$pos" -ne 0 ]; then
				head -c "$(( pos + 1 ))" "$snap" > "$snapinprogress"
			fi
			echo "$key $value" >> "$snapinprogress"
			tail -c "+$(( nextcr + 2 ))" "$snap" >> "$snapinprogress"
		fi
		debug "SET FR0=${findres[0]} FR1=${findres[1]}"
	else
		error "failed to find position for key=$key"
	fi

	mv -f "$snapinprogress" "$snap"
}

# AUTODOC 
# AUTODOC ssdb set KEY VALUE
# AUTODOC ssdb s   KEY VALUE
# AUTODOC 	it sets a KEY to a VALUE
# AUTODOC 	if the KEY was already present it overrides it
function run_set {
	lock GLOBAL
	debug "run_set $1 '$2'"

	local result
	if result="$(_set_key "$1" "$2")"; then
		debug "added"
	else
		local EXIT=$?
		debug "failed to set key, $result"
		unlock GLOBAL
		printf "%s" "$result"
		return $EXIT
	fi

	unlock GLOBAL
	printf 'OK'
	return 0
}

# AUTODOC 
# AUTODOC ssdb add KEY VALUE
# AUTODOC ssdb a   KEY VALUE
# AUTODOC 	it add a new KEY to a VALUE
# AUTODOC 	if the KEY was already present it exits with error
function run_add {
	lock GLOBAL
	debug "run_set $1 '$2'"

	local result
	if result="$(_set_key "$1" "$2" noreplace)"; then
		debug "added"
	else
		local EXIT=$?
		debug "failed to set key, $result"
		unlock GLOBAL
		printf "%s" "$result"
		return $EXIT
	fi

	unlock GLOBAL
	printf 'OK'
	return 0
}

function _delete_key {
	local key="$1"
	local snap
	snap=$(snap_name)

	local findres
	local snapinprogress="$snap.ip"

	if findres=$(find_position_for_key "$snap" "$key"); then
		findres=($findres)
		local postype="${findres[0]}"
		local pos="${findres[1]}"
		if [ "$postype" == "APPEND" ]; then
			return 1
		else
			debug "found key=$key at position=$pos"
			local line
			line=$(get_line "$snap" "$pos")
			local nextcr
			nextcr=$(seek4 "$snap" "$(( pos + 1 ))" "$CR")
			debug "nextcr=$nextcr"
			if [ "$pos" -ne 0 ]; then
				head -c "$(( pos + 1 ))" "$snap" > "$snapinprogress"
			fi
			tail -c "+$(( nextcr + 2 ))" "$snap" >> "$snapinprogress"
		fi
		debug "SET FR0=${findres[0]} FR1=${findres[1]}"
	else
		error "failed to find position for key=$key"
	fi

	mv -f "$snapinprogress" "$snap"
}

# AUTODOC 
# AUTODOC ssdb delete KEY
# AUTODOC ssdb del    KEY
# AUTODOC ssdb d      KEY
# AUTODOC 	it deletes a KEY from ssdb
# AUTODOC 	if the KEY was not found it exits with error
function run_del {
	lock GLOBAL

	debug "run_del $1"
	if _delete_key "$1"; then
		debug "Found"
	else
		local EXIT=$?
		debug "Not found"
		unlock GLOBAL
		return $EXIT
	fi

	unlock GLOBAL

	printf 'OK'
	return 0
}

# returns full line containing key
function _get_line_with_key {
	local key="$1"
	local no_value="${2-}"

	local snap
	snap=$(snap_name)

	while read -r line; do
		debug "[get] scanning for '$key' no_value=$no_value, line='$line'"
		if [ "$(line2key "$line")" == "$key" ]; then
			debug "FOUND $line"
			if [ -z "$no_value" ]; then
				printf '%s' "$line"
			fi
			return 0
		fi
	done < "$snap"
	return 1
}

# AUTODOC 
# AUTODOC ssdb get KEY
# AUTODOC ssdb g   KEY
# AUTODOC 	it returns a VALUE that stands for KEY in ssdb
# AUTODOC 	if the KEY was not found it exits with error
function run_get {
	lock GLOBAL

	debug "run_get $1"
	local line
	if line="$(_get_line_with_key "$1")"; then
		debug "Found line='$line'"
	else
		local EXIT=$?
		debug "Not Found"
		unlock GLOBAL
		return $EXIT
	fi

	unlock GLOBAL

	local fmt
	fmt=$(line2meta "$line" 'format')
	if [ "$fmt" == 'raw' ]; then
		printf '%s' "$(line2value "$line")"
		return 0
	fi

	if [ "$fmt" == 'b64' ]; then
		printf '%s' "$(line2value "$line")" | base64 -d
		return 0
	fi

	error "Unknown fmt=$fmt"
}

# AUTODOC 
# AUTODOC ssdb check KEY
# AUTODOC ssdb c   KEY
# AUTODOC 	it exits with 0 if KEY is present in ssdb
# AUTODOC 	if the KEY was not found it exits with error
function run_check {
	lock GLOBAL

	debug "run_check $1"
	if _get_line_with_key "$1" 1; then
		unlock GLOBAL
		debug "Key present"
		return 0
	else
		local EXIT=$?
		unlock GLOBAL
		debug "Key absent"
		return $EXIT
	fi
}

function _list_keys {
	local snap
	snap=$(snap_name)

	sed 's/ .*//' "$snap"
}

# AUTODOC 
# AUTODOC ssdb list
# AUTODOC ssdb l
# AUTODOC 	returns sorted list of keys in ssdb
function run_list {
	lock GLOBAL

	debug "run_list"
	if result="$(_list_keys)"; then
		unlock GLOBAL
		debug "got keys"
		printf '%s\n' "$result"
		return 0
	else
		local EXIT=$?
		unlock GLOBAL
		debug "failed to list keys"
		return $EXIT
	fi
}


# AUTODOC 
# AUTODOC ssdb snap
# AUTODOC 	returns snapshot as is (can be used for backup needs)
function run_snap {
	lock GLOBAL

	debug "run_snap"
	local snap
	snap=$(snap_name)
	cat "$snap"
	unlock GLOBAL
}

# AUTODOC 
# AUTODOC ssdb bindump
# AUTODOC 	returns binary dumped snapshot (for debug puposes)
function run_bindump {
	lock GLOBAL

	debug "run_snap"
	local snap
	snap=$(snap_name)
	hexdump -ve '1/1 "(%_ad:%02d:"' -e '1/1 "%_c) "' "$snap"
	echo
	unlock GLOBAL
}

# AUTODOC 
# AUTODOC ssdb truncate
# AUTODOC 	deletes everything from ssdb
function run_truncate {
	lock GLOBAL

	debug "run_snap"
	local snap
	snap=$(snap_name)
	printf '' > "$snap"
	unlock GLOBAL
}

COMMAND=""
KEY=""
VALUE=""

while [[ $# -gt 0 ]]; do
	option="$1"
	debug "parsing $option"

	case $option in
		-D|--database|--db)
			SSDB_DATABASE="${2:-}"
			[ -z "$SSDB_DATABASE" ] && error "$option param can not be empty"
			shift
			shift
			;;
		-S|--snapdir)
			SSDB_SNAPDIR="$2"
			[ -z "$SSDB_SNAPDIR" ] && error "$option param can not be empty"
			shift
			shift
			;;
		-d|--debug)
			SSDB_DEBUG=1
			shift
			;;
		*)
			break;;
	esac
done

GIVEN_COMMAND="${1:-}"

case "$GIVEN_COMMAND" in
	a|add|d|del|delete|g|get|c|check|s|set)
		KEY="${2:-}"
		if [ -z "$KEY" ]; then
			error "KEY can't be empty"
		fi
		case "$GIVEN_COMMAND" in
			a|add|s|set)
				case "$GIVEN_COMMAND" in
					a|add)
						COMMAND="add";;
					s|set)
						COMMAND="set";;
				esac

				if [ -z "${3+x}" ]; then
					error "VALUE is undefined"
				else
					VALUE="$3"
					shift
					shift
					shift
				fi
				;;
			d|del|delete)
				COMMAND="del"
				shift
				shift;;
			g|get)
				COMMAND="get"
				shift
				shift;;
			c|check)
				COMMAND="check"
				shift
				shift;;
		esac;;
	l|list)
		COMMAND="list"
		shift;;
	snap)
		COMMAND="snap"
		shift;;
	bindump)
		COMMAND="bindump"
		shift;;
	truncate)
		COMMAND="truncate"
		shift;;
	h|help)
		COMMAND="help"
		shift;;
	'')
		error "No command given, consider running 'ssdb help'";;
	*)
		error "'$GIVEN_COMMAND' command is unknown, consider running 'ssdb help'";;
esac

debug "COMMAND=$COMMAND KEY=$KEY VALUE=$VALUE"
debug "SSDB_SNAPDIR=$SSDB_SNAPDIR"

if [[ $# -gt 0 ]]; then
	error 'extra params left, usage ssdb [OPTIONS] COMMAND ?ARG1 ?ARG2'
fi

case "$COMMAND" in
	add)
		run_add "$KEY" "$VALUE";;
	set)
		run_set "$KEY" "$VALUE";;
	del)
		run_del "$KEY";;
	get)
		run_get "$KEY";;
	check)
		run_check "$KEY";;
	list)
		run_list;;
	snap)
		run_snap;;
	bindump)
		run_bindump;;
	truncate)
		run_truncate;;
	help)
		print_help;;
	*)
		error "'$COMMAND' command is parsed but not implemented yet";;
esac
